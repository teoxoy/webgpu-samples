(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[391],{5671:function(e,n,t){"use strict";t.d(n,{T:function(){return d}});var r=t(5893),a=t(9008),i=t.n(a),o=t(1163),s=t(7294),u=t(9147),c=t.n(u);t(2684),t(7319);let l=e=>{let n=(0,s.useRef)(null),a=(0,s.useMemo)(()=>e.sources.map(e=>{let{name:n,contents:a}=e;return{name:n,...function(e){let n;let a=null;{a=document.createElement("div");let i=t(4631);n=i(a,{lineNumbers:!0,lineWrapping:!0,theme:"monokai",readOnly:!0})}return{Container:function(t){return(0,r.jsx)("div",{...t,children:(0,r.jsx)("div",{ref(t){a&&t&&(t.appendChild(a),n.setOption("value",e))}})})}}}(a)}}),e.sources),u=(0,s.useRef)(null),l=(0,s.useMemo)(()=>{if(e.gui){let n=t(4376);return new n.GUI({autoPlace:!1})}},[]),d=(0,o.useRouter)(),p=d.asPath.match(/#([a-zA-Z0-9\.\/]+)/),[f,m]=(0,s.useState)(null),[g,h]=(0,s.useState)(null);return(0,s.useEffect)(()=>{p?h(p[1]):h(a[0].name),l&&u.current&&u.current.appendChild(l.domElement);let t={active:!0},r=()=>{t.active=!1};try{let i=n.current,o=e.init({canvas:i,pageState:t,gui:l});o instanceof Promise&&o.catch(e=>{console.error(e),m(e)})}catch(s){console.error(s),m(s)}return r},[]),(0,r.jsxs)("main",{children:[(0,r.jsxs)(i(),{children:[(0,r.jsx)("style",{dangerouslySetInnerHTML:{__html:"\n            .CodeMirror {\n              height: auto !important;\n              margin: 1em 0;\n            }\n\n            .CodeMirror-scroll {\n              height: auto !important;\n              overflow: visible !important;\n            }\n          "}}),(0,r.jsx)("title",{children:"".concat(e.name," - WebGPU Samples")}),(0,r.jsx)("meta",{name:"description",content:e.description})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("h1",{children:e.name}),(0,r.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("teoxoy/webgpu-samples","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,r.jsx)("p",{children:e.description}),f?(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)("p",{children:"Is WebGPU Enabled?"}),(0,r.jsx)("p",{children:"".concat(f)})]}):null]}),(0,r.jsxs)("div",{className:c().canvasContainer,children:[(0,r.jsx)("div",{style:{position:"absolute",right:10},ref:u}),(0,r.jsx)("canvas",{ref:n})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("nav",{className:c().sourceFileNav,children:(0,r.jsx)("ul",{children:a.map((e,n)=>(0,r.jsx)("li",{children:(0,r.jsx)("a",{href:"#".concat(e.name),"data-active":g==e.name,onClick(){h(e.name)},children:e.name})},n))})}),a.map((e,n)=>(0,r.jsx)(e.Container,{className:c().sourceFileContainer,"data-active":g==e.name},n))]})]})},d=e=>(0,r.jsx)(l,{...e})},2684:function(){if("end"in GPURenderPassEncoder.prototype||(GPURenderPassEncoder.prototype.end=GPURenderPassEncoder.prototype.endPass),"end"in GPUComputePassEncoder.prototype||(GPUComputePassEncoder.prototype.end=GPUComputePassEncoder.prototype.endPass),navigator.userAgent.indexOf("Firefox")>0){let e={info:{icon:"ℹ️",logFn:console.info},warning:{icon:"⚠️",logFn:console.warn},error:{icon:"⛔",logFn:console.error}},n=GPUDevice.prototype.createShaderModule;function t(e){let n=GPUDevice.prototype[e];GPUDevice.prototype[e]=function(e){return"auto"==e.layout&&delete e.layout,n.call(this,e)}}GPUDevice.prototype.createShaderModule=function(t){t.code=t.code.replaceAll("vec4f","vec4<f32>").replaceAll("vec3f","vec3<f32>").replaceAll("vec2f","vec2<f32>").replaceAll("vec4u","vec4<u32>").replaceAll("vec3u","vec3<u32>").replaceAll("vec2u","vec2<u32>").replaceAll("mat4x4f","mat4x4<f32>");let r=n.call(this,t);return r.compilationInfo().then(n=>{if(!n.messages.length)return;let t={error:0,warning:0,info:0};for(let a of n.messages)t[a.type]+=1;0==t.error&&validationError&&(t.error=1);let i=r.label,o=(i?'"'.concat(i,'"'):"Shader")+" returned compilation messages:";for(let s in t)t[s]>0&&(o+=" ".concat(t[s]).concat(e[s].icon));for(let u of(0==t.error?console.groupCollapsed(o):console.group(o),n.messages)){let c=u.type;e[c].logFn(u.message)}console.groupEnd()}),r},t("createRenderPipeline"),t("createRenderPipelineAsync"),t("createComputePipeline"),t("createComputePipelineAsync");let r=GPUCommandEncoder.prototype.beginRenderPass;GPUCommandEncoder.prototype.beginRenderPass=function(e){if(e.colorAttachments)for(let n of e.colorAttachments)"clear"==n.loadOp?n.loadValue=n.clearValue||[0,0,0,0]:n.loadValue="load";if(e.depthStencilAttachment){let t=e.depthStencilAttachment;"load"==t.depthLoadOp?t.depthLoadValue="load":t.depthLoadValue=t.depthClearValue||1,t.depthStoreOp||(t.depthStoreOp="discard"),"load"==t.stencilClearValue?t.stencilLoadValue="load":t.stencilLoadValue=t.stencilClearValue||0,t.stencilStoreOp||(t.stencilStoreOp="discard")}return r.call(this,e)};let a=HTMLCanvasElement.prototype.getContext;HTMLCanvasElement.prototype.getContext=function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];let r=a.apply(this,n);return"webgpu"==n[0]&&(r.canvas=this),r};let i={},o=GPUCanvasContext.prototype.configure;GPUCanvasContext.prototype.configure=function(e){let n=this;i[n]||(i[n]=new MutationObserver(function(t){let r=!1;for(let a of t)("width"==a.attributeName||"height"==a.attributeName)&&(r=!0);r&&o.call(n,e)})),i[n].observe(n.canvas,{attributes:!0}),o.call(n,e)};let s=GPUCanvasContext.prototype.unconfigure;GPUCanvasContext.prototype.unconfigure=function(e){i[this]&&i[this].disconnect(),s.call(this,e)},GPU.prototype.getPreferredCanvasFormat=function(){return"bgra8unorm"}}},7391:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return l}});var r=t(5671),a="@binding(0) @group(0) var<storage, read> size: vec2<u32>;\n@binding(1) @group(0) var<storage, read> current: array<u32>;\n@binding(2) @group(0) var<storage, read_write> next: array<u32>;\n\nfn getIndex(x: u32, y: u32) -> u32 {\n  let h = size.y;\n  let w = size.x;\n\n  return (y % h) * w + (x % w);\n}\n\nfn getCell(x: u32, y: u32) -> u32 {\n  return current[getIndex(x, y)];\n}\n\nfn countNeighbors(x: u32, y: u32) -> u32 {\n  return getCell(x - 1u, y - 1u) + getCell(x, y - 1u) + getCell(x + 1u, y - 1u) + \n         getCell(x - 1u, y) +                           getCell(x + 1u, y) + \n         getCell(x - 1u, y + 1u) + getCell(x, y + 1u) + getCell(x + 1u, y + 1u);\n}\n\n@compute @workgroup_size(8u, 8u)\nfn main(@builtin(global_invocation_id) grid: vec3<u32>) {\n  let x = grid.x;\n  let y = grid.y;\n  let n = countNeighbors(x, y);\n  next[getIndex(x, y)] = select(u32(n == 3u), u32(n == 2u || n == 3u), getCell(x, y) == 1u); \n} \n",i="struct Out {\n  @builtin(position) pos: vec4<f32>,\n  @location(0) cell: f32,\n}\n\n@binding(0) @group(0) var<uniform> size: vec2<u32>;\n\n@vertex\nfn main(@builtin(instance_index) i: u32, @location(0) cell: u32, @location(1) pos: vec2<u32>) -> Out {\n  let w = size.x;\n  let h = size.y;\n  let x = (f32(i % w + pos.x) / f32(w) - 0.5) * 2. * f32(w) / f32(max(w, h));\n  let y = (f32((i - (i % w)) / w + pos.y) / f32(h) - 0.5) * 2. * f32(h) / f32(max(w, h));\n\n  return Out(vec4<f32>(x, y, 0., 1.), f32(cell));\n}\n",o="@fragment\nfn main(@location(0) cell: f32) -> @location(0) vec4<f32> {\n  return vec4<f32>(cell, cell, cell, 1.);\n}\n",s="src/sample/gameOfLife/main.ts";let u=async e=>{let n,t,{canvas:r,pageState:s,gui:u}=e,c=await navigator.gpu.requestAdapter(),l=await c.requestDevice();if(!s.active)return;let d=r.getContext("webgpu"),p=window.devicePixelRatio||1;r.width=r.clientWidth*p,r.height=r.clientHeight*p;let f=navigator.gpu.getPreferredCanvasFormat();d.configure({device:l,format:f,alphaMode:"premultiplied"});let m={width:128,height:128,timestep:4,workgroupSize:8},g=l.createShaderModule({code:a}),h=l.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),y=new Uint32Array([0,0,0,1,1,0,1,1]),b=l.createBuffer({size:y.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Uint32Array(b.getMappedRange()).set(y),b.unmap();let v={arrayStride:2*y.BYTES_PER_ELEMENT,stepMode:"vertex",attributes:[{shaderLocation:1,offset:0,format:"uint32x2"}]},G=l.createShaderModule({code:i}),P=l.createShaderModule({code:o}),E=l.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),w={arrayStride:Uint32Array.BYTES_PER_ELEMENT,stepMode:"instance",attributes:[{shaderLocation:0,offset:0,format:"uint32"}]},x=0,S=0,C,U;function L(){let e=l.createComputePipeline({layout:l.createPipelineLayout({bindGroupLayouts:[h]}),compute:{module:g,entryPoint:"main",constants:{blockSize:m.workgroupSize}}}),r=l.createBuffer({size:2*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Uint32Array(r.getMappedRange()).set([m.width,m.height]),r.unmap();let a=m.width*m.height,i=new Uint32Array(a);for(let o=0;o<a;o++)i[o]=.25>Math.random()?1:0;C=l.createBuffer({size:i.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Uint32Array(C.getMappedRange()).set(i),C.unmap(),U=l.createBuffer({size:i.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX});let s=l.createBindGroup({layout:h,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:C}},{binding:2,resource:{buffer:U}}]}),u=l.createBindGroup({layout:h,entries:[{binding:0,resource:{buffer:r}},{binding:1,resource:{buffer:U}},{binding:2,resource:{buffer:C}}]}),c=l.createRenderPipeline({layout:l.createPipelineLayout({bindGroupLayouts:[E]}),primitive:{topology:"triangle-strip"},vertex:{module:G,entryPoint:"main",buffers:[w,v]},fragment:{module:P,entryPoint:"main",targets:[{format:f}]}}),p=l.createBindGroup({layout:c.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:0,size:2*Uint32Array.BYTES_PER_ELEMENT}}]});S=0,t=()=>{let t=d.getCurrentTexture().createView();n=l.createCommandEncoder();let r=n.beginComputePass();r.setPipeline(e),r.setBindGroup(0,S?u:s),r.dispatchWorkgroups(m.width/m.workgroupSize,m.height/m.workgroupSize),r.end();let i=n.beginRenderPass({colorAttachments:[{view:t,loadOp:"clear",storeOp:"store"}]});i.setPipeline(c),i.setVertexBuffer(0,S?U:C),i.setVertexBuffer(1,b),i.setBindGroup(0,p),i.draw(4,a),i.end(),l.queue.submit([n.finish()])}}u.add(m,"timestep",1,60,1),u.add(m,"width",16,1024,16).onFinishChange(L),u.add(m,"height",16,1024,16).onFinishChange(L),u.add(m,"workgroupSize",[4,8,16]).onFinishChange(L),L(),function e(){m.timestep&&++x>=m.timestep&&(t(),x-=m.timestep,S=1-S),requestAnimationFrame(e)}()},c=()=>(0,r.T)({name:"Conway's Game of Life",description:"This example shows how to make Conway's game of life. First, use compute shader to calculate how cells grow or die. Then use render pipeline to draw cells by using instance mesh.",gui:!0,init:u,sources:[{name:s.substring(22),contents:"import { makeSample, SampleInit } from '../../components/SampleLayout';\nimport computeWGSL from './compute.wgsl';\nimport vertWGSL from './vert.wgsl';\nimport fragWGSL from './frag.wgsl';\n\nconst init: SampleInit = async ({ canvas, pageState, gui }) => {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n  if (!pageState.active) return;\n  const context = canvas.getContext('webgpu') as GPUCanvasContext;\n  const devicePixelRatio = window.devicePixelRatio || 1;\n  canvas.width = canvas.clientWidth * devicePixelRatio;\n  canvas.height = canvas.clientHeight * devicePixelRatio;\n  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n\n  context.configure({\n    device,\n    format: presentationFormat,\n    alphaMode: 'premultiplied',\n  });\n\n  const GameOptions = {\n    width: 128,\n    height: 128,\n    timestep: 4,\n    workgroupSize: 8,\n  };\n\n  const computeShader = device.createShaderModule({ code: computeWGSL });\n  const bindGroupLayoutCompute = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'read-only-storage',\n        },\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'read-only-storage',\n        },\n      },\n      {\n        binding: 2,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {\n          type: 'storage',\n        },\n      },\n    ],\n  });\n\n  const squareVertices = new Uint32Array([0, 0, 0, 1, 1, 0, 1, 1]);\n  const squareBuffer = device.createBuffer({\n    size: squareVertices.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  new Uint32Array(squareBuffer.getMappedRange()).set(squareVertices);\n  squareBuffer.unmap();\n\n  const squareStride: GPUVertexBufferLayout = {\n    arrayStride: 2 * squareVertices.BYTES_PER_ELEMENT,\n    stepMode: 'vertex',\n    attributes: [\n      {\n        shaderLocation: 1,\n        offset: 0,\n        format: 'uint32x2',\n      },\n    ],\n  };\n\n  const vertexShader = device.createShaderModule({ code: vertWGSL });\n  const fragmentShader = device.createShaderModule({ code: fragWGSL });\n  let commandEncoder: GPUCommandEncoder;\n\n  const bindGroupLayoutRender = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.VERTEX,\n        buffer: {\n          type: 'uniform',\n        },\n      },\n    ],\n  });\n\n  const cellsStride: GPUVertexBufferLayout = {\n    arrayStride: Uint32Array.BYTES_PER_ELEMENT,\n    stepMode: 'instance',\n    attributes: [\n      {\n        shaderLocation: 0,\n        offset: 0,\n        format: 'uint32',\n      },\n    ],\n  };\n\n  function addGUI() {\n    gui.add(GameOptions, 'timestep', 1, 60, 1);\n    gui.add(GameOptions, 'width', 16, 1024, 16).onFinishChange(resetGameData);\n    gui.add(GameOptions, 'height', 16, 1024, 16).onFinishChange(resetGameData);\n    gui\n      .add(GameOptions, 'workgroupSize', [4, 8, 16])\n      .onFinishChange(resetGameData);\n  }\n\n  let wholeTime = 0,\n    loopTimes = 0,\n    buffer0: GPUBuffer,\n    buffer1: GPUBuffer;\n  let render: () => void;\n  function resetGameData() {\n    // compute pipeline\n    const computePipeline = device.createComputePipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayoutCompute],\n      }),\n      compute: {\n        module: computeShader,\n        entryPoint: 'main',\n        constants: {\n          blockSize: GameOptions.workgroupSize,\n        },\n      },\n    });\n    const sizeBuffer = device.createBuffer({\n      size: 2 * Uint32Array.BYTES_PER_ELEMENT,\n      usage:\n        GPUBufferUsage.STORAGE |\n        GPUBufferUsage.UNIFORM |\n        GPUBufferUsage.COPY_DST |\n        GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Uint32Array(sizeBuffer.getMappedRange()).set([\n      GameOptions.width,\n      GameOptions.height,\n    ]);\n    sizeBuffer.unmap();\n    const length = GameOptions.width * GameOptions.height;\n    const cells = new Uint32Array(length);\n    for (let i = 0; i < length; i++) {\n      cells[i] = Math.random() < 0.25 ? 1 : 0;\n    }\n\n    buffer0 = device.createBuffer({\n      size: cells.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX,\n      mappedAtCreation: true,\n    });\n    new Uint32Array(buffer0.getMappedRange()).set(cells);\n    buffer0.unmap();\n\n    buffer1 = device.createBuffer({\n      size: cells.byteLength,\n      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX,\n    });\n\n    const bindGroup0 = device.createBindGroup({\n      layout: bindGroupLayoutCompute,\n      entries: [\n        { binding: 0, resource: { buffer: sizeBuffer } },\n        { binding: 1, resource: { buffer: buffer0 } },\n        { binding: 2, resource: { buffer: buffer1 } },\n      ],\n    });\n\n    const bindGroup1 = device.createBindGroup({\n      layout: bindGroupLayoutCompute,\n      entries: [\n        { binding: 0, resource: { buffer: sizeBuffer } },\n        { binding: 1, resource: { buffer: buffer1 } },\n        { binding: 2, resource: { buffer: buffer0 } },\n      ],\n    });\n\n    const renderPipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({\n        bindGroupLayouts: [bindGroupLayoutRender],\n      }),\n      primitive: {\n        topology: 'triangle-strip',\n      },\n      vertex: {\n        module: vertexShader,\n        entryPoint: 'main',\n        buffers: [cellsStride, squareStride],\n      },\n      fragment: {\n        module: fragmentShader,\n        entryPoint: 'main',\n        targets: [\n          {\n            format: presentationFormat,\n          },\n        ],\n      },\n    });\n\n    const uniformBindGroup = device.createBindGroup({\n      layout: renderPipeline.getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: sizeBuffer,\n            offset: 0,\n            size: 2 * Uint32Array.BYTES_PER_ELEMENT,\n          },\n        },\n      ],\n    });\n\n    loopTimes = 0;\n    render = () => {\n      const view = context.getCurrentTexture().createView();\n      const renderPass: GPURenderPassDescriptor = {\n        colorAttachments: [\n          {\n            view,\n            loadOp: 'clear',\n            storeOp: 'store',\n          },\n        ],\n      };\n      commandEncoder = device.createCommandEncoder();\n\n      // compute\n      const passEncoderCompute = commandEncoder.beginComputePass();\n      passEncoderCompute.setPipeline(computePipeline);\n      passEncoderCompute.setBindGroup(0, loopTimes ? bindGroup1 : bindGroup0);\n      passEncoderCompute.dispatchWorkgroups(\n        GameOptions.width / GameOptions.workgroupSize,\n        GameOptions.height / GameOptions.workgroupSize\n      );\n      passEncoderCompute.end();\n      // render\n      const passEncoderRender = commandEncoder.beginRenderPass(renderPass);\n      passEncoderRender.setPipeline(renderPipeline);\n      passEncoderRender.setVertexBuffer(0, loopTimes ? buffer1 : buffer0);\n      passEncoderRender.setVertexBuffer(1, squareBuffer);\n      passEncoderRender.setBindGroup(0, uniformBindGroup);\n      passEncoderRender.draw(4, length);\n      passEncoderRender.end();\n\n      device.queue.submit([commandEncoder.finish()]);\n    };\n  }\n\n  addGUI();\n  resetGameData();\n\n  (function loop() {\n    if (GameOptions.timestep) {\n      wholeTime++;\n      if (wholeTime >= GameOptions.timestep) {\n        render();\n        wholeTime -= GameOptions.timestep;\n        loopTimes = 1 - loopTimes;\n      }\n    }\n\n    requestAnimationFrame(loop);\n  })();\n};\n\nconst GameOfLife: () => JSX.Element = () =>\n  makeSample({\n    name: \"Conway's Game of Life\",\n    description:\n      \"This example shows how to make Conway's game of life. First, use compute shader to calculate how cells grow or die. Then use render pipeline to draw cells by using instance mesh.\",\n    gui: true,\n    init,\n    sources: [\n      {\n        name: __filename.substring(__dirname.length + 1),\n        contents: __SOURCE__,\n      },\n      {\n        name: './gameOfLife.compute.wgsl',\n        contents: computeWGSL,\n        editable: true,\n      },\n      {\n        name: './gameOfLife.vert.wgsl',\n        contents: vertWGSL,\n        editable: true,\n      },\n      {\n        name: './gameOfLife.frag.wgsl',\n        contents: fragWGSL,\n        editable: true,\n      },\n    ],\n    filename: __filename,\n  });\n\nexport default GameOfLife;\n"},{name:"./gameOfLife.compute.wgsl",contents:a,editable:!0},{name:"./gameOfLife.vert.wgsl",contents:i,editable:!0},{name:"./gameOfLife.frag.wgsl",contents:o,editable:!0}],filename:s});var l=c},9147:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__zRR_l",sourceFileNav:"SampleLayout_sourceFileNav__ml48P",sourceFileContainer:"SampleLayout_sourceFileContainer__3s84x"}}}]);